/*----- PROTECTED REGION ID(Scheduler.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        Scheduler.cpp
//
// description : C++ source for the Scheduler class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Scheduler are implemented in this file.
//
// project :     Scheduler
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Scheduler.h>
#include <SchedulerClass.h>

#include <Message.h>
#include <Argument.h>
#include <SysUtils.h>

#include <TaskManager.h>

#include <iomanip>
#include <chrono>

/*----- PROTECTED REGION END -----*/	//	Scheduler.cpp

/**
 *  Scheduler class description:
 *    Device server providing command scheduling functionalities
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name      |  Method name
//================================================================
//  State             |  Inherited (no method)
//  Status            |  Inherited (no method)
//  ScheduleTask      |  schedule_task
//  TestSchedule      |  test_schedule
//  FlushTaskQueue    |  flush_task_queue
//  RevokeTask        |  revoke_task
//  GetNQueuedTasks   |  get_nqueued_tasks
//  GetNRunningTasks  |  get_nrunning_tasks
//  PrintTasks        |  print_tasks
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//================================================================

namespace Scheduler_ns
{
/*----- PROTECTED REGION ID(Scheduler::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	Scheduler::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : Scheduler::Scheduler()
 *	Description : Constructors for a Tango device
 *                implementing the classScheduler
 */
//--------------------------------------------------------
Scheduler::Scheduler(Tango::DeviceClass *cl, string &s)
 : BaseDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Scheduler::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::constructor_1
}
//--------------------------------------------------------
Scheduler::Scheduler(Tango::DeviceClass *cl, const char *s)
 : BaseDevice(cl, s)
{
	/*----- PROTECTED REGION ID(Scheduler::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::constructor_2
}
//--------------------------------------------------------
Scheduler::Scheduler(Tango::DeviceClass *cl, const char *s, const char *d)
 : BaseDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(Scheduler::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : Scheduler::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Scheduler::delete_device()
{
	DEBUG_STREAM << "Scheduler::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects

	
	
	/*
	//## Delete task callback
	if(m_TaskCallBack){
		DEBUG_STREAM << "Scheduler::delete_device(): DEBUG: Deleting task callback..." << endl;
		delete m_TaskCallBack;
		m_TaskCallBack= 0;
	}
	*/

	
	//## Waits for an existing thread to finish
	if (m_SchedulerThread) {
		DEBUG_STREAM << "Scheduler::delete_device(): DEBUG: Shutting down scheduler thread..." << endl;	
		m_mutex->lock();
	  m_StopThreadFlag= true;
		//m_wait_condition->signal();
    m_mutex->unlock();
		
    if(m_TaskManager) m_TaskManager->End();
		  
    DEBUG_STREAM << "Scheduler::delete_device(): DEBUG: Waiting for thread to finish..."<< endl;
    void *ptr;
   	m_SchedulerThread->join(&ptr);
    m_SchedulerThread = 0;
	}


	if(m_TaskManagerThread){
		DEBUG_STREAM << "Scheduler::delete_device(): DEBUG: Shutting down scheduler thread..." << endl;	
		
		if(m_TaskManager) m_TaskManager->End();

		delete m_TaskManagerThread;
		m_TaskManagerThread = 0;
	}


	
	//## Delete task manager
	if(m_TaskManager){
		DEBUG_STREAM << "Scheduler::delete_device(): DEBUG: Deleting task manager..." << endl;
		delete m_TaskManager;
		m_TaskManager= 0;
	}		
	

	/*
	//## Delete mutex
	if(m_wait_condition){
		DEBUG_STREAM << "Scheduler::delete_device(): DEBUG: Deleting wait_condition..." << endl;
    delete m_wait_condition;
    m_wait_condition= 0;
	}

  if(m_mutex) {
  	DEBUG_STREAM << "Scheduler::delete_device(): DEBUG: Deleting mutex..." << endl;
    delete m_mutex;
    m_mutex= 0;
  }
  */
 
	/*----- PROTECTED REGION END -----*/	//	Scheduler::delete_device

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		BaseDevice_ns::BaseDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : Scheduler::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void Scheduler::init_device()
{
	DEBUG_STREAM << "Scheduler::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		BaseDevice_ns::BaseDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(Scheduler::init_device) ENABLED START -----*/
	
	//	Initialize device
	InitDispatcher();

	/*----- PROTECTED REGION END -----*/	//	Scheduler::init_device
}

//--------------------------------------------------------
/**
 *	Method      : Scheduler::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void Scheduler::get_device_property()
{
	/*----- PROTECTED REGION ID(Scheduler::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("max_queueable_tasks"));
	dev_prop.push_back(Tango::DbDatum("thread_heartbeat_period"));
	dev_prop.push_back(Tango::DbDatum("max_trackable_tasks"));
	dev_prop.push_back(Tango::DbDatum("max_cacheable_device_proxies"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SchedulerClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SchedulerClass	*ds_class =
			(static_cast<SchedulerClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize max_queueable_tasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  max_queueable_tasks;
		else {
			//	Try to initialize max_queueable_tasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  max_queueable_tasks;
		}
		//	And try to extract max_queueable_tasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  max_queueable_tasks;

		//	Try to initialize thread_heartbeat_period from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  thread_heartbeat_period;
		else {
			//	Try to initialize thread_heartbeat_period from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  thread_heartbeat_period;
		}
		//	And try to extract thread_heartbeat_period value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  thread_heartbeat_period;

		//	Try to initialize max_trackable_tasks from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  max_trackable_tasks;
		else {
			//	Try to initialize max_trackable_tasks from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  max_trackable_tasks;
		}
		//	And try to extract max_trackable_tasks value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  max_trackable_tasks;

		//	Try to initialize max_cacheable_device_proxies from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  max_cacheable_device_proxies;
		else {
			//	Try to initialize max_cacheable_device_proxies from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  max_cacheable_device_proxies;
		}
		//	And try to extract max_cacheable_device_proxies value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  max_cacheable_device_proxies;

	}

	/*----- PROTECTED REGION ID(Scheduler::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : Scheduler::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Scheduler::always_executed_hook()
{
	DEBUG_STREAM << "Scheduler::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : Scheduler::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Scheduler::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Scheduler::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Scheduler::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::read_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : Scheduler::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Scheduler::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Scheduler::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Read pipe FinalResponse related method
 *	Description: Task final response data structure
 */
//--------------------------------------------------------
void Scheduler::read_FinalResponse(Tango::Pipe &pipe)
{
	DEBUG_STREAM << "Scheduler::read_FinalResponse(Tango::Pipe &pipe) entering... " << endl;
	/*----- PROTECTED REGION ID(Scheduler::read_FinalResponse) ENABLED START -----*/
	
	//	Add your own code here

	std::string pipe_name= "FinalResponse";
		pipe.set_name(pipe_name);
		pipe.set_root_blob_name("FinalResponse");
		std::vector<std::string> de_names {"x","y"};
		pipe.set_data_elt_names(de_names);

		double x= 4.5;
		double y= 6.7;
		pipe << x << y;

	try {	
		//Tango::Pipe& dev_pipe= this->get_device_class()->get_pipe_by_name("FinalResponse");
		//Tango::DevicePipeBlob& dev_pipe_blob= dev_pipe.get_blob();
		//pipe << dev_pipe_blob;
		//std::vector<Tango::Pipe*>& pipes= this->get_device_class()->get_pipe_list(); 
		//pipe= *(pipes[0]);
	
		/*
		Tango::Pipe* dev_pipe= (pipes[0]);
		std::string pipe_name= "FinalResponse";
		dev_pipe->set_name(pipe_name);
		dev_pipe->set_root_blob_name("FinalResponse");
		std::vector<std::string> de_names {"x","y"};
		dev_pipe->set_data_elt_names(de_names);
		
		double x= 4.5;
		double y= 6.7;
		(*dev_pipe) ["x"] << x;
		(*dev_pipe) ["y"] << y;

		INFO_STREAM<<"pto 1"<<endl;
		Tango::DevicePipeBlob& dev_pipe_blob= dev_pipe->get_blob();
		INFO_STREAM<<"pto 2"<<endl;

		INFO_STREAM<<"get_root_blob_name ()="<<dev_pipe->get_root_blob_name()<<endl;
		INFO_STREAM<<"get_data_elt_nb="<<dev_pipe_blob.get_data_elt_nb()<<endl;
		*/
		
		/*
		Tango::DevicePipeBlob blob1;
		blob1.set_name("blob1");
		std::vector<std::string> blob1_fields {"id","name"};
		blob1.set_data_elt_names(blob1_fields);
		blob1["id"] << std::string("id1");
		blob1["name"] << std::string("cmd1");

		Tango::DevicePipeBlob blob2;
		blob2.set_name("blob2");
		std::vector<std::string> blob2_fields {"id","name"};
		blob2.set_data_elt_names(blob2_fields);
		blob2["id"] << std::string("id2");
		blob2["name"] << std::string("cmd2");
	
		dev_pipe.set_root_blob_name("FinalResponse");
		std::vector<std::string> de_names {"blob1","blob2"};
		dev_pipe.set_data_elt_names(de_names);
		dev_pipe << blob1 << blob2;
	
		INFO_STREAM<<"pto 1"<<endl;
		Tango::DevicePipeBlob& dev_pipe_blob= dev_pipe.get_blob();
		INFO_STREAM<<"pto 2"<<endl;

		INFO_STREAM<<"get_root_blob_name ()="<<dev_pipe.get_root_blob_name()<<endl;
		*/
		/*
		Tango::Pipe& dev_pipe= this->get_device_class()->get_pipe_by_name("FinalResponse");
		std::string pipe_name= "FinalResponse";
		dev_pipe.set_name(pipe_name);
		dev_pipe.set_root_blob_name("FinalResponse");
		std::vector<std::string> de_names {"x","y"};
		dev_pipe.set_data_elt_names(de_names);
		
		double x= 4.5;
		double y= 6.7;
		dev_pipe ["x"] << x;
		dev_pipe ["y"] << y;

		INFO_STREAM<<"pto 1"<<endl;
		Tango::DevicePipeBlob& dev_pipe_blob= dev_pipe.get_blob();
		INFO_STREAM<<"pto 2"<<endl;

		INFO_STREAM<<"get_root_blob_name ()="<<dev_pipe.get_root_blob_name()<<endl;
		*/
		
		//pipe.set_root_blob_name("FinalResponse");
		//pipe.set_data_elt_nb(1);
		//INFO_STREAM<<"pto 3"<<endl;

		//pipe << dev_pipe_blob;
		//INFO_STREAM<<"pto 4"<<endl;
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		ERROR_STREAM << "read_FinalResponse(): ERROR: Tango exception occurred while setting pipe!"<<endl;	
	}
	catch(std::exception &e){
		ERROR_STREAM << "read_FinalResponse(): ERROR: Run time exception occurred (e="<<e.what()<<") while setting pipe!"<<endl;	
	}
	catch(...){
		ERROR_STREAM << "read_FinalResponse(): ERROR: Unknown exception occurred while setting pipe!"<<endl;	
	}
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::read_FinalResponse
}
//--------------------------------------------------------
/**
 *	Read pipe IntermediateResponse related method
 *	Description: intermediate task response data structure
 */
//--------------------------------------------------------
void Scheduler::read_IntermediateResponse(Tango::Pipe &pipe)
{
	DEBUG_STREAM << "Scheduler::read_IntermediateResponse(Tango::Pipe &pipe) entering... " << endl;
	/*----- PROTECTED REGION ID(Scheduler::read_IntermediateResponse) ENABLED START -----*/
	
	//	Add your own code here
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::read_IntermediateResponse
}
//--------------------------------------------------------
/**
 *	Read pipe queued_tasks related method
 *	Description: Queued tasks
 */
//--------------------------------------------------------
void Scheduler::read_queued_tasks(Tango::Pipe &pipe)
{
	DEBUG_STREAM << "Scheduler::read_queued_tasks(Tango::Pipe &pipe) entering... " << endl;
	/*----- PROTECTED REGION ID(Scheduler::read_queued_tasks) ENABLED START -----*/
	
	//	Add your own code here
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::read_queued_tasks
}
//--------------------------------------------------------
/**
 *	Read pipe tasks related method
 *	Description: Task collection pipe
 */
//--------------------------------------------------------
void Scheduler::read_tasks(Tango::Pipe &pipe)
{
	DEBUG_STREAM << "Scheduler::read_tasks(Tango::Pipe &pipe) entering... " << endl;
	/*----- PROTECTED REGION ID(Scheduler::read_tasks) ENABLED START -----*/
	
	//	Add your own code here

	
	//## Get task collection pipe from manager
	try {
		DEBUG_STREAM<<"Scheduler::read_tasks(): INFO: Reading task pipe from manager..."<<endl;
		pipe.set_root_blob_name("tasks");
		if(m_TaskManager->GetTaskPipe(pipe)<0){
			ERROR_STREAM<<"Scheduler::read_tasks(): ERROR: Failed to read task collection pipe from manager!"<<endl;	
			return;
		}	
		pipe.set_root_blob_name("tasks");
		DEBUG_STREAM<<"Scheduler::read_tasks(): INFO: Setting pipe name..."<<endl;
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		ERROR_STREAM<<"Scheduler::read_tasks(): ERROR: Failed to write pipe!"<<endl;	
		return;	
	}


	/*
	Tango::DevicePipeBlob blob1;
	blob1.set_name("blob1");
	std::vector<std::string> blob1_fields {"id","name"};
	blob1.set_data_elt_names(blob1_fields);
	blob1["id"] << std::string("id1");
	blob1["name"] << std::string("cmd1");

	Tango::DevicePipeBlob blob2;
	blob2.set_name("blob2");
	std::vector<std::string> blob2_fields {"id","name"};
	blob2.set_data_elt_names(blob2_fields);
	blob2["id"] << std::string("id2");
	blob2["name"] << std::string("cmd2");
	
	pipe.set_root_blob_name("tasks");
	std::vector<std::string> de_names {"blob1","blob2"};
	pipe.set_data_elt_names(de_names);
	pipe << blob1 << blob2;
	*/

	/*
	pipe.set_root_blob_name("tasks");
	std::vector<std::string> de_names {"EvenFirstDE","EvenSecondDE"};
	pipe.set_data_elt_names(de_names);
	long int dl = 666;
	std::vector<double> v_db;
	v_db.push_back(3.5);
	v_db.push_back(4.7);

	pipe << dl << v_db;
	*/

	/*----- PROTECTED REGION END -----*/	//	Scheduler::read_tasks
}
//--------------------------------------------------------
/**
 *	Command ScheduleTask related method
 *	Description: Schedule a command
 *
 *	@param argin [0]: Request arg 
 *               [1]: Proxy device name to be contacted for request
 *               [2]: Command name in proxy device (optional)
 *	@returns Long arg
 *           [0]: ack
 *           
 *           String arg
 *           [0]: err/info description
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *Scheduler::schedule_task(const Tango::DevVarStringArray *argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "Scheduler::ScheduleTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::schedule_task) ENABLED START -----*/
	
	//	Add your own code
	
	//============================
	//==   INIT REPLY DATA
	//============================
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);
	
	//============================
	//==   VALIDATE ARGS
	//============================
	//Validate request args
	int nargs= argin->length();
	if(nargs<3){
		ack= -1;
		reply= "Missing args";
		argout->lvalue[0]= ack;	
		argout->svalue[0]= CORBA::string_dup(reply.c_str());
		return argout;
	}
	std::string cmd_args= std::string((*argin)[0]);
	std::string cmd_device= std::string((*argin)[1]);
	std::string cmd_name= std::string((*argin)[2]);
	//============================
	//==   VALIDATE CMD ARGS
	//============================
	MessageParser_ns::Request req;
	if(req.Parse(cmd_args)<0){
		WARN_STREAM<<"Scheduler::ScheduleTask(): WARN: Invalid task args given!"<<endl;
		ack= -1;
		reply= "Invalid task args";
		argout->lvalue[0]= ack;	
		argout->svalue[0]= CORBA::string_dup(reply.c_str());
		return argout;
	}
		
	//Check request args
	if(!req.HasField("arguments") || !req.HasField("activation_time")){
		WARN_STREAM<<"Scheduler::ScheduleTask(): WARN: Missing task args or activation time!"<<endl;
		//...	
		ack= -1;
		reply= "Missing task args";
		argout->lvalue[0]= ack;	
		argout->svalue[0]= CORBA::string_dup(reply.c_str());
		return argout;
	}
	//Get activation/expiration time
	std::string t_start= req.GetActivationTime();	
	std::string t_end= "";
	if(req.HasField("expiration_time")) t_end= req.GetExpirationTime();
	//Get cmd id
	std::string cmd_id= req.GetId();

	//============================
	//==   SCHEDULE TASK
	//============================
	int status= Schedule(cmd_id,cmd_name,t_start,cmd_args.c_str(),t_end,cmd_device);
	if(status<0){
		WARN_STREAM<<"Scheduler::ScheduleTask(): ERROR: Failed to schedule command!"<<endl;
		//...	
		ack= -1;
		reply= "Failed to schedule command";
		argout->lvalue[0]= ack;	
		argout->svalue[0]= CORBA::string_dup(reply.c_str());
		return argout;
	}

	INFO_STREAM<<"Scheduler::ScheduleTask(): INFO: End command	 ..."<<endl;
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());		

	/*----- PROTECTED REGION END -----*/	//	Scheduler::schedule_task
	return argout;
}
//--------------------------------------------------------
/**
 *	Command TestSchedule related method
 *	Description: 
 *
 *	@param argin 
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *Scheduler::test_schedule(Tango::DevString argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "Scheduler::TestSchedule()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::test_schedule) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	std::string cmd_argin= std::string(argin);

	INFO_STREAM<<"TestSchedule(): INFO: cmd_argin="<<cmd_argin<<endl;

	Tango::ApiUtil::instance()->set_asynch_cb_sub_model(Tango::PUSH_CALLBACK);
	Tango::DeviceProxy* device_proxy= 0;
	try{
		device_proxy= new Tango::DeviceProxy("DSHLMC/LMCInterface/id1");
	}
	catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		ERROR_STREAM << "TestSchedule(): ERROR: Failed to connect to proxy device "<<device_name<<endl;
		if(device_proxy){
			delete device_proxy;
			device_proxy= 0;
		}	
		ack= -1;
		reply= "Failed to connect to proxy device!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	
	//Set command argument data  
  Tango::DeviceData din; 
	INFO_STREAM<<"TestSchedule(): INFO: Set command argument data ..."<<endl;
  try { 
		//Tango::DevString argin_string;
		//*argin_any >>= argin_string;
  	//din<<argin_string;
		din<<argin;
  } 
  catch(Tango::DevFailed& e){
		Tango::Except::print_exception(e);
		ERROR_STREAM<<"TestSchedule(): ERROR: Failed to set command argument data!"<<endl;
		if(device_proxy){
			delete device_proxy;
			device_proxy= 0;
		}
		ack= -1;
		reply= "Failed to set command argument data!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());		
		return argout;
	}      

	// Execute command asynchronously	
	INFO_STREAM<<"TestSchedule(): INFO: Execute command asynchronously	 ..."<<endl;
	try{
		device_proxy->command_inout_asynch("echo",din,*m_TaskCallBack); 
		//Tango::ApiUtil::instance()->get_asynch_replies();

		//Tango::DeviceData dout= device_proxy->command_inout("echo",din);  

		//std::string argout_string;
		//dout>>argout_string;
		//INFO_STREAM<<"TestSchedule(): INFO: argout_string="<<argout_string<<endl;
	}
	catch (Tango::DevFailed &e) { 
  	Tango::Except::print_exception(e); 
		ERROR_STREAM<<"TestSchedule(): ERROR: Failed to execute async command!"<<endl;
		if(device_proxy){
			delete device_proxy;
			device_proxy= 0;
		}
		ack= -1;
		reply= "Failed to execute async command!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());		
		return argout;
  }

	INFO_STREAM<<"TestSchedule(): INFO: End command	 ..."<<endl;
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());		

	/*----- PROTECTED REGION END -----*/	//	Scheduler::test_schedule
	return argout;
}
//--------------------------------------------------------
/**
 *	Command FlushTaskQueue related method
 *	Description: Flush the task queue. All tasks in the queue will be removed.
 *               Idle tasks only will be removed from the task list history.
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *Scheduler::flush_task_queue()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "Scheduler::FlushTaskQueue()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::flush_task_queue) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);
	//Flushing the task queue
	if(m_TaskManager->FlushQueue()<0){
		ERROR_STREAM<<"Scheduler::FlushTaskQueue(): ERROR: Failed to flush the task queue"<<endl;
		ack= -1;
		reply= "Failed to flush the task queue";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());			
	/*----- PROTECTED REGION END -----*/	//	Scheduler::flush_task_queue
	return argout;
}
//--------------------------------------------------------
/**
 *	Command RevokeTask related method
 *	Description: Remove a task with given id from the queue and also from
 *               the task history list.
 *
 *	@param argin Task id
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *Scheduler::revoke_task(Tango::DevString argin)
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "Scheduler::RevokeTask()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::revoke_task) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	argout->svalue.length(1);

	//Check arg
	if(argin==""){
		ERROR_STREAM<<"Scheduler::RevokeTask(): ERROR: Invalid argument given!"<<endl;
		ack= -1;
		reply= "Invalid argument given (empty string)!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
		return argout;
	}

	//Removing task from the  task queue
	if(m_TaskManager->RemoveTask(argin)<0){
		ERROR_STREAM<<"Scheduler::RevokeTask(): ERROR: Failed to remove task from the task queue!"<<endl;
		ack= -1;
		reply= "Failed to remove task from the task queue";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());
	}
	argout->lvalue[0]= ack;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());			
	/*----- PROTECTED REGION END -----*/	//	Scheduler::revoke_task
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNQueuedTasks related method
 *	Description: Return the number of tasks actually present in the queue
 *
 *	@returns Long arg
 *           [0]: ack code 
 *           [1]: current queue size
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *Scheduler::get_nqueued_tasks()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "Scheduler::GetNQueuedTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::get_nqueued_tasks) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	long int nqueued= -1;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(2);
	argout->svalue.length(1);

	nqueued= m_TaskManager->GetNTasksInQueue();

	argout->lvalue[0]= ack;
	argout->lvalue[1]= nqueued;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());		

	/*----- PROTECTED REGION END -----*/	//	Scheduler::get_nqueued_tasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetNRunningTasks related method
 *	Description: Get number of running tasks
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *Scheduler::get_nrunning_tasks()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "Scheduler::GetNRunningTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::get_nrunning_tasks) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	long int nrunning= -1;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(2);
	argout->svalue.length(1);

	nrunning= m_TaskManager->GetNRunningTasks();

	argout->lvalue[0]= ack;
	argout->lvalue[1]= nrunning;
	argout->svalue[0] = CORBA::string_dup(reply.c_str());		

	/*----- PROTECTED REGION END -----*/	//	Scheduler::get_nrunning_tasks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PrintTasks related method
 *	Description: Print tasks present in the list (mainly for debugging purpose)
 *
 */
//--------------------------------------------------------
void Scheduler::print_tasks()
{
	DEBUG_STREAM << "Scheduler::PrintTasks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Scheduler::print_tasks) ENABLED START -----*/
	
	//	Add your own code
	m_TaskManager->PrintTasks();

	/*----- PROTECTED REGION END -----*/	//	Scheduler::print_tasks
}
//--------------------------------------------------------
/**
 *	Method      : Scheduler::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void Scheduler::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(Scheduler::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	Scheduler::add_dynamic_commands
}

/*----- PROTECTED REGION ID(Scheduler::namespace_ending) ENABLED START -----*/

//	Additional Methods
void Scheduler::InitDispatcher(){

  //## Create main zmq context
  //DEBUG_STREAM << "Scheduler::InitDispatcher(): DEBUG: Init zmq context..."<< endl;
  //context= 0;
  //context = zmq_ctx_new();
   
	//## Init mutex
  DEBUG_STREAM << "Scheduler::InitDispatcher(): DEBUG: Init mutex..."<< endl;
  m_mutex= 0;
  m_mutex = new omni_mutex();

	//m_wait_condition= 0;
	//m_wait_condition = new omni_condition(m_mutex);

	//## Init Task CallBack	
	Tango::ApiUtil::instance()->set_asynch_cb_sub_model(Tango::PUSH_CALLBACK);
	m_TaskCallBack= 0;
	m_TaskCallBack= new TaskCallBack(this);
	
	
	//## Init task manager
	m_TaskManager= 0;
	m_TaskManager= new TaskManager(this,m_TaskCallBack);
	m_TaskManager->SetMaxNTasksInQueue(max_queueable_tasks);
	m_TaskManager->SetMaxNTasksInCollection(max_trackable_tasks);
	m_TaskManager->SetMaxCachedDevProxies(max_cacheable_device_proxies);

	//## Start the scheduler thread
  DEBUG_STREAM << "Scheduler::InitDispatcher(): DEBUG: Init scheduler thread..."<< endl;
  m_StopThreadFlag= false;
	m_SchedulerThread= 0;
  //m_SchedulerThread = new SchedulerThread(this);
  //m_SchedulerThread->start_undetached();


	m_TaskManagerThread = 0;
	m_TaskManagerThread= new TaskManagerThread(this);
	m_TaskManagerThread->Start();

}//close InitDispatcher() 

template<typename T>
int Scheduler::Schedule(std::string cmd_id,std::string cmd_name,std::string t_start,T cmd_argin,std::string t_end,std::string cmd_device){

	//============================
	//==    Set flags	
	//============================
	bool isCoLocatedCmd= true;
	if(cmd_device!="") isCoLocatedCmd= false;
	bool hasExpirationTime= false;
	if(t_end!="") hasExpirationTime= true;
		
	//============================
	//==    Initialize
	//============================
	Tango::DeviceImpl* ds_impl= 0;
	Tango::DeviceClass* ds_class= 0;
	try {	
		ds_impl= Tango::Util::instance()->get_device_by_name(device_name);
		ds_class= ds_impl->get_device_class();
	}
	catch(Tango::DevFailed& e){
		WARN_STREAM<<"Scheduler::Schedule(): WARN: Failed to get DeviceImpl/DeviceClass instances"<<endl;
		return -1;
	}

	//==================================
	//==    Check timestamp arguments
	//==================================
	//--> Check activation time and convert to timestamp	
	if(t_start==""){
		WARN_STREAM<<"Scheduler::Schedule(): WARN: Invalid activation timestamp arg (empty string given)"<<endl;
		return -1;
	}
	//std::time_t epoch_start_local= Utils_ns::SysUtils::TimeStringToLocalEpoch(t_start);
	//auto t_start_local= Utils_ns::SysUtils::TimeStringToLocalChronoTimeStamp(t_start);	
	std::time_t epoch_start_local= Utils_ns::SysUtils::TimeStringToUTCEpoch(t_start);
	auto t_start_local= Utils_ns::SysUtils::TimeStringToUTCChronoTimeStamp(t_start);
	DEBUG_STREAM<<"Scheduler::Schedule(): DEBUG: t_start="<<t_start<<" epoch_start_local="<<epoch_start_local<<endl;

	//--> Reject command if activation time passed
	auto now = std::chrono::system_clock::now();
	if(t_start_local<now){
		WARN_STREAM<<"Scheduler::Schedule(): WARN: Invalid activation time (timestamp passed)!"<<endl;
		return -1;
	}

	//--> Check expiration time and convert to timestamp	
	auto t_end_local= t_start_local;
	if(hasExpirationTime) {
		//std::time_t epoch_end_local= Utils_ns::SysUtils::TimeStringToLocalEpoch(t_end);
		//t_end_local= Utils_ns::SysUtils::TimeStringToLocalChronoTimeStamp(t_end);
		std::time_t epoch_end_local= Utils_ns::SysUtils::TimeStringToUTCEpoch(t_end);
		t_end_local= Utils_ns::SysUtils::TimeStringToUTCChronoTimeStamp(t_end);
		DEBUG_STREAM<<"Scheduler::Schedule(): DEBUG: t_end="<<t_end<<" epoch_end_local="<<epoch_end_local<<endl;
	}//close if


	
	//==================================================
	//==    Check device & command name arguments
	//==================================================
	//--> Check cmd name given (in case of co-located call check if device has a command with given name)	
	CORBA::Any* cmd_args_any= 0;
	std::string device_name= "";

	if(cmd_name=="" || cmd_id=="") {	
		WARN_STREAM<<"Scheduler::Schedule(): WARN: Invalid command name/id args (empty string given)"<<endl;
		return -1;
	}

	Tango::DeviceData din;
	if(isCoLocatedCmd){		
		device_name= this->get_name();

		//Check if command exists on this device	
		try {	
			Tango::Command& cmd= ds_class->get_cmd_by_name(cmd_name);
			Tango::CmdArgType argin_type= cmd.get_in_type();
			cmd_args_any= cmd.insert(cmd_argin);

			din<<cmd_argin;
		}		
		catch(Tango::DevFailed& e){
			WARN_STREAM<<"Scheduler::Schedule(): WARN: Invalid command name given (command "<<cmd_name<<" does not exist on this device)"<<endl;
			return -1;
		}
	}//close if co-located call
	else{	
		device_name= cmd_device;

		//Check is given device exists on the control system
		WARN_STREAM<<"Scheduler::Schedule(): INFO: Checking if device "<<device_name<<" and command "<<cmd_name<<" actually exist..."<<endl;
			
		Tango::DeviceProxy* dev_proxy= 0;	
		bool isValidDeviceAndCommand= true;
		try {
			dev_proxy= new Tango::DeviceProxy(device_name);
			dev_proxy->command_query(cmd_name);
		}
		catch(Tango::ConnectionFailed& e){
			Tango::Except::print_exception(e);
		
			for(int i=0;i<e.errors.length();i++){
				Tango::DevString reason= e.errors[i].reason;	
				DEBUG_STREAM<<"Scheduler::Schedule(): WARN: Exception occurred (reason: "<<reason<<")"<<endl;
			
				if( strcmp(reason,"API_DeviceNotDefined")==0 ||
						strcmp(reason,"DB_DeviceNotDefined")==0
				){
					WARN_STREAM<<"Scheduler::Schedule(): WARN: Invalid device name given (reason: "<<reason<<")"<<endl;
					isValidDeviceAndCommand= false;
					break;
				}
			}//end loop exceptions
		}//close catch ConnectionFailed
		catch(Tango::WrongNameSyntax& e){
			Tango::Except::print_exception(e);
			WARN_STREAM<<"Scheduler::Schedule(): WARN: Given device does not exist (invalid syntax)"<<endl;
			isValidDeviceAndCommand= false;	
		}//close catch WrongNameSyntax
		catch(Tango::DevFailed& e){
			Tango::Except::print_exception(e);
		
			for(int i=0;i<e.errors.length();i++){
				Tango::DevString reason= e.errors[i].reason;	
				DEBUG_STREAM<<"Scheduler::Schedule(): WARN: Exception occurred (reason: "<<reason<<")"<<endl;
			
				if( strcmp(reason,"API_CommandNotFound")==0 ){
					WARN_STREAM<<"Scheduler::Schedule(): WARN: Invalid device name given (reason: "<<reason<<")"<<endl;
					isValidDeviceAndCommand= false;
					break;
				}
			}//end loop exceptions
		}//close catch ConnectionFailed

		//Clear tmp device proxy
		if(dev_proxy){
			delete dev_proxy;
			dev_proxy= 0;
		}

		if(!isValidDeviceAndCommand){
			WARN_STREAM<<"Scheduler::Schedule(): WARN: Failed to verify device name and command given, task will not be added!"<<endl;
			return -1;
		}

		//Insert 
		try {	
			din<<cmd_argin;
		}
		catch(Tango::DevFailed& e){
			WARN_STREAM<<"Scheduler::Schedule(): WARN: Failed to insert argin to DeviceData!"<<endl;
			return -1;
		}
	}//close else

	//========================================================
	//==    Check number of queued tasks/device proxies
	//========================================================
	int nQueuedTasks= m_TaskManager->GetNTasksInQueue();
	if(nQueuedTasks>=max_queueable_tasks){
		ERROR_STREAM<<"Scheduler::Schedule(): WARN: Too many queued tasks (n="<<nQueuedTasks<<", limit exceeded, refuse task!"<<endl;
		return -1;
	}
 
	int nTasks= m_TaskManager->GetNTasksInCollection();
	if(nTasks>=max_trackable_tasks){
		ERROR_STREAM<<"Scheduler::Schedule(): WARN: Too many tasks in coollection (n="<<nTasks<<", limit exceeded, refuse task!"<<endl;
		return -1;
	}
	
	int nCachedDevices= m_TaskManager->GetNCachedDevProxies();
	if(nCachedDevices>=max_cacheable_device_proxies){
		ERROR_STREAM<<"Scheduler::Schedule(): WARN: Too many cached proxy devices (n="<<nCachedDevices<<", limit exceeded, refuse task!"<<endl;
		return -1;
	}
	
	//===============================
	//==    Add new task in queue
	//===============================
	Task task(cmd_id,cmd_name,device_name,t_start_local,t_end_local,din);
	m_TaskManager->AddTask(task);

	
	return 0;

}//clse Scheduler::Schedule()



Tango::DevicePipe Scheduler::SetTaskPipe(Task& task){

	//Create the final response pipe
	Tango::DevicePipe taskPipe("task");
	std::vector<std::string> field_names {"id","name","device_name","exec_status","status","tstart","tend"};
	taskPipe.set_data_elt_names(field_names);

	return taskPipe;

}//close CreateAndPushFinalRespPipe()


/*----- PROTECTED REGION END -----*/	//	Scheduler::namespace_ending
} //	namespace
