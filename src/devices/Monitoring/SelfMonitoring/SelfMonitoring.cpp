/*----- PROTECTED REGION ID(SelfMonitoring.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        SelfMonitoring.cpp
//
// description : C++ source for the SelfMonitoring class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               SelfMonitoring are implemented in this file.
//
// project :     SelfMonitoring
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <SelfMonitoring.h>
#include <SelfMonitoringClass.h>

#include <ZMQUtils.h>
#include <SocketUtils.h>

#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h> 
#include <sys/un.h>

/*----- PROTECTED REGION END -----*/	//	SelfMonitoring.cpp

/**
 *  SelfMonitoring class description:
 *    Device server to perform host/service self-monitoring
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name                  |  Method name
//================================================================
//  State                         |  Inherited (no method)
//  Status                        |  Inherited (no method)
//  DevConfigure                  |  Inherited (no method)
//  RestoreDevConfig              |  Inherited (no method)
//  RemoveAttr                    |  Inherited (no method)
//  RemoveAttrs                   |  Inherited (no method)
//  SubscribeAttr                 |  Inherited (no method)
//  UnsubscribeAttr               |  Inherited (no method)
//  SubscribeAttrs                |  Inherited (no method)
//  UnsubscribeAttrs              |  Inherited (no method)
//  SubscribeToServiceChecks      |  subscribe_to_service_checks
//  SubscribeToHostChecks         |  subscribe_to_host_checks
//  UnsubscribeFromServiceChecks  |  unsubscribe_from_service_checks
//  UnsubscribeFromHostChecks     |  unsubscribe_from_host_checks
//  ListChannels                  |  list_channels
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//  tmpAttr  |  Tango::DevDouble	Scalar
//================================================================

namespace SelfMonitoring_ns
{
/*----- PROTECTED REGION ID(SelfMonitoring::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::SelfMonitoring()
 *	Description : Constructors for a Tango device
 *                implementing the classSelfMonitoring
 */
//--------------------------------------------------------
SelfMonitoring::SelfMonitoring(Tango::DeviceClass *cl, string &s)
 : BaseDevice(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(SelfMonitoring::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::constructor_1
}
//--------------------------------------------------------
SelfMonitoring::SelfMonitoring(Tango::DeviceClass *cl, const char *s)
 : BaseDevice(cl, s)
{
	/*----- PROTECTED REGION ID(SelfMonitoring::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::constructor_2
}
//--------------------------------------------------------
SelfMonitoring::SelfMonitoring(Tango::DeviceClass *cl, const char *s, const char *d)
 : BaseDevice(cl, s, d)
{
	/*----- PROTECTED REGION ID(SelfMonitoring::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void SelfMonitoring::delete_device()
{
	DEBUG_STREAM << "SelfMonitoring::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	//## Waits for an existing thread to finish
	if(CloseSocket()<0){
		ERROR_STREAM<<"SelfMonitoring::delete_device(): ERROR: Failed to close unix socket to Nagios Query Handler!"<<endl;
	}

	if (m_NagiosListenerThread) {
		DEBUG_STREAM << "SelfMonitoring::delete_device(): DEBUG: Shutting down Nagios listener thread..." << endl;	
		m_mutex->lock();
	  m_StopThreadFlag= true;
		m_mutex->unlock();
    DEBUG_STREAM << "SelfMonitoring::delete_device(): DEBUG: Waiting for thread to finish..."<< endl;
    void *ptr;
   	m_NagiosListenerThread->join(&ptr);
    m_NagiosListenerThread = 0;
	}


	//## Close ZMQ sockets
	if(m_ZmqSock) {
		DEBUG_STREAM<<"SelfMonitoring::delete_device(): INFO: Closing zmq socket..."<<endl;
		zmq_close(m_ZmqSock);
	}
	if(m_ZmqContext) {
		DEBUG_STREAM<<"SelfMonitoring::delete_device(): INFO: Shutting down zmq context..."<<endl;
		zmq_ctx_destroy (m_ZmqContext);
	}

	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::delete_device

	if (Tango::Util::instance()->is_svr_shutting_down()==false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false &&
		Tango::Util::instance()->is_svr_starting()==false)
	{
		//	If not shutting down call delete device for inherited object
		BaseDevice_ns::BaseDevice::delete_device();
	}
}

//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void SelfMonitoring::init_device()
{
	DEBUG_STREAM << "SelfMonitoring::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::init_device_before
	
	if (Tango::Util::instance()->is_svr_starting() == false  &&
		Tango::Util::instance()->is_device_restarting(device_name)==false)
	{
		//	If not starting up call init device for inherited object
		BaseDevice_ns::BaseDevice::init_device();
	}

	//	Get the device properties from database
	get_device_property();
	
	/*----- PROTECTED REGION ID(SelfMonitoring::init_device) ENABLED START -----*/
	
	//	Initialize device
	
	
	//## Initialize and connect socket
	if(InitSocket()<0){
		ERROR_STREAM<<"SelfMonitoring::init_device(): ERROR: Failed to initialize and connect unix scket to Nagios Query Handler!"<<endl;
	}

	//## Init mutex
  DEBUG_STREAM << "SelfMonitoring::init_device(): DEBUG: Init mutex..."<< endl;
  m_mutex= 0;
  m_mutex = new omni_mutex();

	//## Init zmq context
	m_ZmqContext = zmq_ctx_new();

	//## Init NAGIOS listener thread
	m_StopThreadFlag= false;
	m_NagiosListenerThread= 0;
  m_NagiosListenerThread = new NagiosListenerThread(this,m_ZmqContext);
  m_NagiosListenerThread->start_undetached();

	//## Init zmq socket	
	//m_ZmqSock = zmq_socket (m_ZmqContext, ZMQ_REQ);
	m_ZmqSock = zmq_socket (m_ZmqContext, ZMQ_DEALER);

	char identity [10];
	sprintf (identity, "%04X-%04X", randof (0x10000), randof (0x10000));
	zmq_setsockopt (m_ZmqSock, ZMQ_IDENTITY, identity, strlen (identity));

	int val = 0;//in ms (0=destroy messages immediately, -1=wait foreever)
	int rc = zmq_setsockopt(m_ZmqSock, ZMQ_LINGER, &val, sizeof(val));
	zmq_connect (m_ZmqSock, "inproc://dispatcher");


	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::init_device
}

//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void SelfMonitoring::get_device_property()
{
	/*----- PROTECTED REGION ID(SelfMonitoring::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("configFile"));
	dev_prop.push_back(Tango::DbDatum("nagios_query_handler"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on SelfMonitoringClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		SelfMonitoringClass	*ds_class =
			(static_cast<SelfMonitoringClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize configFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFile;
		else {
			//	Try to initialize configFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFile;
		}
		//	And try to extract configFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFile;

		//	Try to initialize nagios_query_handler from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  nagios_query_handler;
		else {
			//	Try to initialize nagios_query_handler from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  nagios_query_handler;
		}
		//	And try to extract nagios_query_handler value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  nagios_query_handler;

	}

	/*----- PROTECTED REGION ID(SelfMonitoring::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void SelfMonitoring::always_executed_hook()
{
	DEBUG_STREAM << "SelfMonitoring::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void SelfMonitoring::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SelfMonitoring::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void SelfMonitoring::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "SelfMonitoring::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::write_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void SelfMonitoring::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(SelfMonitoring::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command SubscribeToServiceChecks related method
 *	Description: Subscribe to receive service checks from Nagios 
 *               NERD
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SelfMonitoring::subscribe_to_service_checks()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SelfMonitoring::SubscribeToServiceChecks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::subscribe_to_service_checks) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	

	//Send cmd to dispatcher
	Utils_ns::ZMQUtils::SBuffer sndBuffer;
	sndBuffer.data= "@nerd subscribe servicechecks\0";
	sndBuffer.size= 30;

	Utils_ns::ZMQUtils::ZMQSendOptions SndOptions;
  SndOptions.send_empty= false;
  SndOptions.send_topic= false;
  SndOptions.topic= "";
  SndOptions.send_identity= false;
  SndOptions.sendmore= false;
  SndOptions.identity= "";

	Utils_ns::ZMQUtils::ZMQRcvOptions RcvOptions;
  RcvOptions.rcv_empty= false;
  RcvOptions.rcv_topic= false;
  RcvOptions.rcv_identity= false;
	RcvOptions.rcvmore= false;

	std::vector<Utils_ns::ZMQUtils::SBuffer> recvBuffers;
	int nMaxMsg= 1;
	int poll_timeout= 10;//in ms
	int read_timeout= 5;
	int recvStatus= Utils_ns::ZMQUtils::sendrcv_message(recvBuffers,m_ZmqSock,sndBuffer,SndOptions,RcvOptions,nMaxMsg,poll_timeout,read_timeout);
	if(recvStatus<0){
		argout->svalue.length(1);
		ack= -1;
		reply= "Failed to read reply from socket!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());	
		return argout;
	}

	INFO_STREAM<<"SelfMonitoring::SubscribeToServiceChecks(): INFO: Received "<<recvBuffers.size()<<" replies from Nagios server..."<<endl;
	
	//Set command reply
	argout->lvalue[0]= ack;
	argout->svalue.length(recvBuffers.size());
	for(unsigned int i=0;i<recvBuffers.size();i++){
		argout->svalue[i] = CORBA::string_dup((recvBuffers[i].data).c_str());	
	}

	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::subscribe_to_service_checks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SubscribeToHostChecks related method
 *	Description: Subscribe to receive host checks from Nagios NERD
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SelfMonitoring::subscribe_to_host_checks()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SelfMonitoring::SubscribeToHostChecks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::subscribe_to_host_checks) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::subscribe_to_host_checks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command UnsubscribeFromServiceChecks related method
 *	Description: Unsubscribe from Nagios service check channel
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SelfMonitoring::unsubscribe_from_service_checks()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SelfMonitoring::UnsubscribeFromServiceChecks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::unsubscribe_from_service_checks) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::unsubscribe_from_service_checks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command UnsubscribeFromHostChecks related method
 *	Description: Unsubscribe from host check channel
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SelfMonitoring::unsubscribe_from_host_checks()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SelfMonitoring::UnsubscribeFromHostChecks()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::unsubscribe_from_host_checks) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::unsubscribe_from_host_checks
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ListChannels related method
 *	Description: List available Nagios channels
 *
 *	@returns 
 */
//--------------------------------------------------------
Tango::DevVarLongStringArray *SelfMonitoring::list_channels()
{
	Tango::DevVarLongStringArray *argout;
	DEBUG_STREAM << "SelfMonitoring::ListChannels()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(SelfMonitoring::list_channels) ENABLED START -----*/
	
	//	Add your own code
	std::string reply= "Request executed with success";
	long int ack= 0;
	argout= new Tango::DevVarLongStringArray;
	argout->lvalue.length(1);
	

	//Send cmd to dispatcher
	Utils_ns::ZMQUtils::SBuffer sndBuffer;
	sndBuffer.data= "@nerd list\0";
	sndBuffer.size= 11;

	Utils_ns::ZMQUtils::ZMQSendOptions SndOptions;
  SndOptions.send_empty= false;
  SndOptions.send_topic= false;
  SndOptions.topic= "";
  SndOptions.send_identity= false;
  SndOptions.sendmore= false;
  SndOptions.identity= "";

	Utils_ns::ZMQUtils::ZMQRcvOptions RcvOptions;
  RcvOptions.rcv_empty= false;
  RcvOptions.rcv_topic= false;
  RcvOptions.rcv_identity= false;
	RcvOptions.rcvmore= false;


	//Utils_ns::ZMQUtils::send_message(m_ZmqSock,sndBuffer,SndOptions);

	std::vector<Utils_ns::ZMQUtils::SBuffer> recvBuffers;
	int nMaxMsg= 1;
	int poll_timeout= 10;//in ms
	int read_timeout= 5;
	int recvStatus= Utils_ns::ZMQUtils::sendrcv_message(recvBuffers,m_ZmqSock,sndBuffer,SndOptions,RcvOptions,nMaxMsg,poll_timeout,read_timeout);
	if(recvStatus<0){
		argout->svalue.length(1);
		ack= -1;
		reply= "Failed to read reply from socket!";
		argout->lvalue[0]= ack;
		argout->svalue[0] = CORBA::string_dup(reply.c_str());	
		return argout;
	}

	INFO_STREAM<<"SelfMonitoring::ListChannels(): INFO: Received "<<recvBuffers.size()<<" replies from Nagios server..."<<endl;
	
	//Set command reply
	argout->lvalue[0]= ack;
	argout->svalue.length(recvBuffers.size());
	for(unsigned int i=0;i<recvBuffers.size();i++){
		argout->svalue[i] = CORBA::string_dup((recvBuffers[i].data).c_str());	
	}

	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::list_channels
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : SelfMonitoring::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void SelfMonitoring::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(SelfMonitoring::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::add_dynamic_commands
}

/*----- PROTECTED REGION ID(SelfMonitoring::namespace_ending) ENABLED START -----*/

//	Additional Methods
int SelfMonitoring::InitSocket(){

	//## Check is socket is already open
	if(m_sockfd>0){
		INFO_STREAM << "SelfMonitoring::InitSocket(): INFO: Socket already init and connected..." << endl;
 		return 0;
	}

	INFO_STREAM << "SelfMonitoring::InitSocket(): INFO: Init unix socket for communication with Nagios Query Handler..." << endl;
 
	//## Define socket vars
  struct timeval timeout;
	timeout.tv_sec = 5;
	timeout.tv_usec = 0; 	

  struct sockaddr_un remote_socket_name;
 	int len;
  long arg; 
  int retval;
  fd_set fdset;

	//## Open socket
	m_sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
  if(m_sockfd<0) {
  	ERROR_STREAM << "SelfMonitoring::InitSocket(): failed to open socket!"<< endl;
    set_state(Tango::FAULT);
    set_status("ERROR: Cannot open socket!");
		return -1;
  }

  //## Set non-blocking socket and connect
	INFO_STREAM << "SelfMonitoring::InitSocket(): INFO: Trying to connect to socket "<<nagios_query_handler<<" ..."<<endl;
    
	memset(&remote_socket_name , 0 , sizeof ( struct sockaddr_un ) ) ;
	remote_socket_name.sun_family = AF_UNIX;
  strncpy(remote_socket_name.sun_path, nagios_query_handler.c_str(),sizeof(remote_socket_name.sun_path)-1);
  len= sizeof(struct sockaddr_un);

	//Set socket non-blocking 
  arg = fcntl(m_sockfd, F_GETFL, NULL);
  arg |= O_NONBLOCK; 
  fcntl(m_sockfd, F_SETFL, arg); 
  
 
	DEBUG_STREAM << "SelfMonitoring::InitSocket(): INFO: Calling connect..."<< endl;
	retval = connect( m_sockfd, (struct sockaddr*)&remote_socket_name,len );

  if( errno == EINPROGRESS){
		DEBUG_STREAM << "SelfMonitoring::InitSocket(): INFO: Socket connect in EINPROGRESS status..."<< endl;
  	
		FD_ZERO(&fdset);      
		FD_SET(m_sockfd, &fdset);

		if( select( m_sockfd+1, 0, &fdset, 0, &timeout) ){

			int result;
			socklen_t result_len = sizeof(result);
			if (getsockopt(m_sockfd, SOL_SOCKET, SO_ERROR, &result, &result_len) < 0) {
    		ERROR_STREAM << "SelfMonitoring::InitSocket(): Socket connection failed!" << endl;
				set_state(Tango::FAULT);
	    	set_status("Socket connection error!");
				return -1;
			}

			if (result != 0) { // connection failed; error code is in 'result'
    		ERROR_STREAM << "SelfMonitoring::InitSocket(): Socket connection failed!" << endl;
				set_state(Tango::FAULT);
	    	set_status("Socket connection error!");
				return -1;
			}
				
			INFO_STREAM << "SelfMonitoring::InitSocket(): Socket connection opened with success" << endl; 
			set_state(Tango::ON);
			set_status("Socket connection opened with success");		
		}//close if select
		else{
			ERROR_STREAM << "SelfMonitoring::InitSocket(): Socket connection failed!" << endl;
			set_state(Tango::FAULT);
	    set_status("Socket connection error!");
			return -1;
		}
  }//close if errno == EINPROGRESS 
  else if (retval < 0) {
		ERROR_STREAM << "SelfMonitoring::InitSocket(): Socket connect() returned error: " <<strerror(errno)<<" !"<< endl; 
		set_state(Tango::FAULT);
		set_status("Socket connection error!");
		return -1;
  }//close else if
  else {
		INFO_STREAM << "SelfMonitoring::InitSocket(): Connection open with success"<< endl; 
		set_state(Tango::ON);
		set_status("Socket connection opened with success");
  }//close else

 	return 0;

}//close OpenSocket()

int SelfMonitoring::CloseSocket(){

	//## Close socket if open
  DEBUG_STREAM << "SelfMonitoring::CloseSocket(): INFO: Closing socket..." << endl;
  if (m_sockfd > 0){
    close(m_sockfd);
  } 
	return 0;

}//close CloseSocket()


ssize_t SelfMonitoring::WriteSocket(const char* buffer, size_t bufsize) {
	if(bufsize<=0) return 0;
  return write(m_sockfd, buffer, bufsize);
}//close WriteSocket

ssize_t SelfMonitoring::ReadSocket(char* buffer, size_t bufsize, int timeout) {
	
	//Indefinite wait read
  if (timeout <= 0) {
    ssize_t n= read(m_sockfd, buffer, bufsize);
    return n;
  }
    
	//Read with timeout
  if (WaitForSocketReadEvent(timeout) == true) {
    return read(m_sockfd, buffer, bufsize);
  }
  return eConnectionTimedOut;

}//close ReadSocket()


int SelfMonitoring::WaitForSocketReadEvent(int timeout) {
    
  fd_set sdset;
  struct timeval tv;

  tv.tv_sec = timeout;
  tv.tv_usec = 0;
  FD_ZERO(&sdset);
  FD_SET(m_sockfd, &sdset);
  if (select(m_sockfd+1, &sdset, NULL, NULL, &tv) > 0) {
    return 0;
  }
  return -1;
}


// //--------------------------------------------------------
// /**
//  *	Read attribute SystemLoad related method
//  *	Description: 
//  *
//  *	Data type:	Tango::DevString
//  *	Attr type:	Spectrum max = 10
//  */
// //--------------------------------------------------------
// void SelfMonitoring::read_SystemLoad(Tango::Attribute &attr)
// {
// 	DEBUG_STREAM << "SelfMonitoring::read_SystemLoad(Tango::Attribute &attr) entering... " << endl;
// 	//	Set the attribute value
// 	attr.set_value(attr_SystemLoad_read, 10);
// 	
// }


/*----- PROTECTED REGION END -----*/	//	SelfMonitoring::namespace_ending
} //	namespace
